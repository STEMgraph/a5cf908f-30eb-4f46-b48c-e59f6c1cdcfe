\learningobjective{At the end of this challenge, the scholar will be able to use `std::accumulate` to compute aggregate values from a range in C++.}
\begin{challenge}
    \chatitle{Using `std::accumulate` to process container elements}
    \begin{chadescription}
    The C++ standard algorithm `std::accumulate` is a versatile tool that allows you to compute aggregate values (like sums, products, or custom operations) from elements in a range.
    It is part of the `<numeric>` header and works with any container that supports iterators.
    Unlike manual loops, `std::accumulate` provides a concise and expressive way to compute aggregate results by combining elements of a range.
    
    Key characteristics of `std::accumulate` include:
    \begin{itemize}
        \item Accepting an initial value for accumulation.
        \item Supporting custom binary operations for flexible aggregation.
        \item Allowing a functional programming style in C++.
    \end{itemize}

    In this challenge, we will:
    \begin{enumerate}
        \item Learn the syntax and basic usage of `std::accumulate`.
        \item Use `std::accumulate` to calculate sums and products.
        \item Explore custom accumulation logic using lambda functions.
    \end{enumerate}
    \end{chadescription}

    \begin{task}
    Write a C++ program to calculate the sum of elements in a `std::vector<int>` using `std::accumulate`.
    \begin{enumerate}
        \item Include the `<numeric>` and `<vector>` headers.
        \item Create a `std::vector<int>` with values `{1, 2, 3, 4, 5}`.
        \item Use `std::accumulate` to calculate the sum of all elements and print the result.
    \end{enumerate}
    \begin{questions}
        \item What is the initial value in the context of `std::accumulate`? Why is it necessary?
        \item How does `std::accumulate` handle the combination of elements?
    \end{questions}
    \end{task}

    \begin{advice}
        `std::accumulate` is a template function, meaning it can operate on any type as long as the provided operation and initial value are compatible with that type.
    \end{advice}

    \begin{task}
    Modify the previous program to calculate the product of all elements in the vector.
    \begin{enumerate}
        \item Change the initial value to `1` (the identity element for multiplication).
        \item Pass a lambda function as the binary operation that multiplies two numbers.
        \item Print the resulting product.
    \end{enumerate}
    \begin{questions}
        \item What happens if you pass `0` as the initial value when computing the product? Why?
        \item Can `std::accumulate` be used with floating-point types? If so, what considerations should be taken regarding precision?
    \end{questions}
    \end{task}

    \begin{advice}
        Use `std::accumulate` with custom operations for flexible aggregation tasks, such as concatenating strings or computing statistics.
    \end{advice}

    \begin{task}
    Use `std::accumulate` to concatenate strings stored in a `std::vector<std::string>`.
    \begin{enumerate}
        \item Create a `std::vector<std::string>` with the values `{"C++", "is", "awesome"}`.
        \item Use `std::accumulate` to concatenate the strings with a space between each word.
        \item Print the resulting sentence.
    \end{enumerate}
    \begin{questions}
        \item What role does the initial value play in string concatenation using `std::accumulate`?
        \item Could this task be performed using a manual loop? Which approach is cleaner and why?
    \end{questions}
    \end{task}

    \begin{advice}
        When concatenating strings, ensure the initial value accounts for any desired prefix or formatting.
    \end{advice}

\end{challenge}
